# C\# Programming

**解释型语言与编译型语言:**

- 编译型语言：预先编译，执行时无需再编译，高性能，对平台依赖。

- 解释型语言：不预先编译，执行时再解释，增加了封装，性能略差，对平台独立。

C\#介于编译型语言与解释型语言之间，先编译成中间语言IL，再由.NET框架解释执行。

**.NET core:** 为了和Linux竞争从.NET框架中抽出的开源部分，用于和C++进行通讯。

**程序集:** 代码本身+库。

**查看IL:** VS2017/VS2017用于开发人员的Console，输入idsm【？】返回项目文件夹路径。IL DASM软件定位到项目文件夹/bin/Debug(Release)/xxx.exe(app)反汇编为IL。

## C语言

**标识符:** 变量名、函数名。

**命名方法:** 驼峰式用于变量、帕斯卡(大驼峰)式用于函数。还有被淘汰的匈牙利式。

**堆与栈:** 栈stack是一级内存，较快，用于放置local变量。栈heap是二级内存，较慢，自己申请malloc(new)和释放delete(如C#中有垃圾回收器GC，会自动管理堆上的内存(托管堆)，有引用计数reference counter)。

**命名空间:** 类比文件夹和文件，同一文件夹下不可有重名文件，路径可嵌套。类比包名。合作开发，每个人应有自己的命名空间。

**项目路径:** 避免中文和空格。

**类与文件名:** C#建议一个文件放一个类，文件名与类名一致。Unity对此强制要求。

### 类型

**内建类型:** 整数、浮点数、字符、字符串

**浮点数:** decimal用于金融计算，绝对精确。浮点比较注意精确位数，可用相减与容差进行比较。字面量有指数指数计数法和十六进制两种。除零时有NaN，向上(下)溢出时有(-)Infinity。

**字符编码:** ASCII一个字符一个字节、unicode一个字符两个字节。编译器只认英文半角的字符。

**字符类型:** 转义(特殊)字符。

**字符串字面量:** 在字符串开始加上@，则转义字符全都不转义，空格全都不合并。保证换行后也属于同一个字符串，\r\n也会直接输入，不再起到换行的效果。

**字符串插值:** 双引号前加上\$，在{}中的内容作为表达式(可编译)，能输入参数；双引号前没有\$的情况，{}中的内容为字符串后,后的参数编号。要输出{}则需要写作{{}}。\$@可同步实现上面的两个效果。`{<interpolationExpression>[,<alignment>][:<formatString>]}`

**常量:** 编译时即可确定值的变量，标识`const`后提升性能。

**隐式类型的局部变量:** `var`由编译器判断实际类型，可以提高代码效率，但不宜过度使用。

**值与引用:** struct为值；class为引用，用关键词new来分配/创建/实例化新的对象。

**可空修饰符?:** 值类型一般不能为空，?使值类型可为空。`int? canNull = null;`

**显示/强制类型转换:** 可能会造成数据溢出。`(转化为的类型名)`可用关键字check/unchecked标识代码块，如发生数据溢出则抛出异常。C\#不支持从数值类型到布尔类型的转换。

**调用方法进行类型转换:** `value.Prase()`和`object.ToString()`等。

### 语句

**控制结构:** 顺序、选择、循环。

**顺序:** 从上到下。

**选择:** if和switch。

**循环:** for, foreach, while和do-while。

**断点:** 用于调试。

### 数组

同一类型多个数据。一维或多维，可通过下标访问，定长。

**初始化:** 各个内建类型都有默认值，自定义类通过*递归*的方式进行初始化。

**多维数组:** 每一维大小必须一致。`[,]`

**交错数组:** 每一维的大小并不一定一致，但都要被实例化。`[][]`

**获取长度:** 避免数组越界。`array.GetLength(int dimension)`

**获取维度:** 只读变量。`array.Rank`

**一维方法:** 排序`System.Array.Sort(array)`二分查找`System.Array.BinarySearch(...)`所有元素恢复默认`array.Clear()`

**字符串作为数组:** string是char[]。

### 操作符

**维度:** 一维、二维、三维。优先级不同。

**类型:** 算数、布尔逻辑、条件、空结合(C\# 6.0)。

**重载:** 如果自己实现的自定义类想要使用+-*/等操作符则需要实现。

## 面向对象

### 接口和继承

**程序:** 数据+方法

**类:** 将数据隐藏起来只暴露方法(封装)

**继承:** 单向

**依赖:** 类中的方法中的参数是其他类

**基类与派生类:** 即父类与子类

**转型操作符:** 自定义类型转换，explicit/implicit operator

**单继承:** C++支持的多继承C#不支持，可以用聚合(将类作为成员变量)的方式解决

用is操作符验证基础类型，用as操作符进行转换(失败不会报错，会为null，而强制类型转换会在运行时报错)

**接口:** 能做什么

**显式实现与隐式实现**

### 委托与事件

**委托:** 类似于C的函数指针，C++的函数对象，Java的反射。提升代码封装性(可以将函数中的一段抽取出来，使得函数得以确定下来不再需要根据需求改动)。是一个委托调用链。

```cs
list.ForEach(n => Console.WriteLine(n));
```

**Func:** 适用于有返回类型的委托。泛型，尖括号中是参数列表+返回值的类型。

**Action:** 仅适用于无返回类型的委托。泛型，尖括号中为参数列表的类型。

**Predicate:** 适用于返回布尔类型的委托。泛型，尖括号中为参数列表的类型。

**lambda:** 表达式(一行)，语句(多行)。=>称为fat arrow。参数类型可以推断时可以省略类型名。单个参数可以省略参数的括号。表达式可以省略return关键词和表达式的括号。其中如果捕获了外部变量，在lambda退出后对该外部变量的改变也依然有效。

**术语:** +=订阅/注册， -=取消订阅/注销， 调用：发布/通知/广播

**应用:** UI事件，技能效果结算。

**解耦合:** 发布者和订阅者完全无关。

**要点:** 排除非空情况，逐个委托调用(跳过有异常的委托者，不让异常影响其他委托者)。

**事件:** 只能+=或-=。
